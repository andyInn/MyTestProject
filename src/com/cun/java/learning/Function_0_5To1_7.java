package com.cun.java.learning;

/**
生成随机数一到七，实际就是随机生成一个数，由三个bit组成，能从1-5随机生成0-1就可以的了，
（这个可以随机生成0-7----如果为0继续生成一次，直到非零就生成1-7的随机数了）

func_1_7()
{
    i = func_0_7();
    while(i==0) {i= func_0_7();}
    return i;
}

func_0_7()
{
    i = 0;
    i |= func_0_1();
    i |= func_0_1()<<1;
    i |= func_0_1()<<2;
    return i;
}

func_0_1()
{
   do{
         i=func_1_5();
       }while (i==5) 
    return i%2;
}

====================
基本方法就是产生一串序列
1,4,5,3,2,4
然后前后两两划分为一组，比如(1,4),(5,3)，因为总共有5X5 =25种等概率的可能，不能被7整除，可以拿掉4种，这样剩下21种，编号为#1,#2,...#21
如果出现#1,#2,#3则输出1，....如果出现#19,#20,#21则输出7，如果出现了被拿掉的那4种情况则忽略之
====================
这个其实和算法导论上的一个题很像么：已知random等概率返回0或者1，那么试写一个函数等概率返回[a,b]之间的整数。
思路就是2进制表示[0, b-a]之间的数，先计算出至少需要多少位，按位生成一个二进制数，一旦大于b-a就重新生成。放到这里的话，表示成5进制就可以了~

推广一下：对于等概率可以生成k个连续整数函数的函数randomk，设计生成[a,b]之间的整数的算法：
令n = b - a;则等概率生成[0，n]上的一个整数即可。于是用k进制表示生成的整数，设m=ceiling(logk(n)),
int randN() {
  while (res > n) {
     for (i = 0; i < m; i++)  
         gen bit i for res with randomk
  }
  return res;
}
期望的运行时间为t*m* i * (1 - (n+1)/k^m)^(i-1) * ((n+1)/k^m)，i从1加到无穷，t表示randomk的运行时间，那么计算这个级数的值为t*m*k^m/(n+1).
带入到这个题目，期望运行时间为50*t/7，还是很快的。
====================

int s = 0, i;
for(i = 0; i < 7; i++) s += rand5();
return s % 7;
====================
int random_1_7()
{
        while(1)
        {
                char tmp = random_1_5()*random_1_5();
                if(tmp > 8 ||tmp < 2)
                        continue;
                else
                        return tmp - 1;
        }
}
解释： random_1_5()*random_1_5()的结果中2，3，4，5，6，7，8出现的概率都为24分之2（概率相等）.
把其他的结果全部舍弃，那么他们的概率就都变为7分之一。tmp-1后就得到了平均概率的1-7.
====================
关于f能产生1--5之间的数，要设计等概率产生1---7之间的数，我觉得可以这样说，因为1--7这些数均可用三位2进制表示，而1--5之间的数任意两两 或 的话，所得的数就是1--7之间的任意数，所以可以如此设计：
f_1_7(){
return f()|f();
}
这样子就能等概率的产生1--7之间的数。
*/